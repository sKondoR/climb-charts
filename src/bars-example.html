<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Colored Vertical Bars</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- Import Three.js and OrbitControls from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Setup scene, camera, renderer ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111122);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 10, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // optional, adds nicer shadows
        document.body.appendChild(renderer.domElement);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 5, 0);

        // --- Lights ---
        // Ambient light to soften shadows
        const ambientLight = new THREE.AmbientLight(0x404060);
        scene.add(ambientLight);

        // Main directional light (like the sun)
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        dirLight.receiveShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        const d = 20;
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        dirLight.shadow.camera.near = 1;
        dirLight.shadow.camera.far = 30;
        scene.add(dirLight);

        // Fill light from the opposite side
        const fillLight = new THREE.DirectionalLight(0xffcc88, 0.5);
        fillLight.position.set(-10, 5, -10);
        scene.add(fillLight);

        // Optional grid helper and ground plane
        const gridHelper = new THREE.GridHelper(30, 20, 0x888888, 0x444444);
        scene.add(gridHelper);

        // A subtle ground plane to catch shadows (semi-transparent)
        const planeGeometry = new THREE.CircleGeometry(15, 32);
        const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x2a2a4a, side: THREE.DoubleSide, transparent: true, opacity: 0.3 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = 0;
        plane.receiveShadow = true;
        scene.add(plane);

        // --- Create colored vertical bars ---
        const barCount = 15; // total bars in grid (adjust as needed)
        const spacing = 1;
        const cols = 1; // number of columns
        const rows = Math.ceil(barCount / cols);

        for (let i = 0; i < barCount; i++) {
            // Calculate grid position (centered around origin)
            const col = i % cols;
            const row = Math.floor(i / cols);
            
            // Center the grid: offset by half width/depth
            const x = (col - (cols - 1) / 2) * spacing;
            const z = (row - (rows - 1) / 2) * spacing;
            
            // Random height between 1 and 8
            const height = 1 + Math.random() * 7;
            
            // Create a box with width/depth fixed, height variable
            const geometry = new THREE.BoxGeometry(1, height, 1);
            
            // Generate a color based on position and height (HSL)
            const hue = (i / barCount + 0.5) % 1.0; // cycle through hues
            const saturation = 0.9;
            const lightness = 0.6;
            const color = new THREE.Color().setHSL(hue, saturation, lightness);
            
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                emissive: 0x000000,
                roughness: 0.3,
                metalness: 0.1
            });
            
            const bar = new THREE.Mesh(geometry, material);
            bar.castShadow = true;
            bar.receiveShadow = true;
            
            // Position: y = half height so base sits on ground plane (y=0)
            bar.position.set(x, height / 2, z);
            
            scene.add(bar);
        }

        // Optional: add some floating particles or stars for effect
        const starsGeometry = new THREE.BufferGeometry();
        const starsCount = 500;
        const starPositions = new Float32Array(starsCount * 3);
        for (let i = 0; i < starsCount * 3; i += 3) {
            starPositions[i] = (Math.random() - 0.5) * 100;
            starPositions[i+1] = (Math.random() - 0.5) * 40;
            starPositions[i+2] = (Math.random() - 0.5) * 100;
        }
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starsMaterial = new THREE.PointsMaterial({ color: 0x888888, size: 0.2 });
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // --- Animation loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            controls.update(); // required if damping enabled
            
            renderer.render(scene, camera);
        }
        
        animate();

        // --- Handle window resize ---
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>