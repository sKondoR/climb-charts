<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Mountain with Trees</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.6);
            padding: 8px 15px;
            border-radius: 30px;
            pointer-events: none;
            font-size: 14px;
            backdrop-filter: blur(5px);
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">üèîÔ∏è Mountain with Trees ‚Ä¢ Drag to view ‚Ä¢ Three.js</div>

    <!-- Import Three.js core and add-ons -->
    <script type="importmap">
        {
            "imports": {
                "three": "./lib/three/three/three.module.js",
                "three/examples/jsm/controls/OrbitControls": "./lib/three/three/OrbitControls.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from './lib/three/three/OrbitControls.js';
        import { findContourPoints } from './lib/three/findContourPoints.js';
        import { createContourLines } from './lib/three/contourLines2.js';

        // --- Setup scene, camera, renderer ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xaaccff); // Soft sky blue
        scene.fog = new THREE.Fog(0xaaccff, 20, 50); // Gentle fog for depth

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 6, 15);
        camera.lookAt(0, 2, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enable shadows for better realism
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.2; // Limit below horizon
        controls.target.set(0, 2, 0);

        // --- Lighting ---
        // Ambient base
        const ambientLight = new THREE.AmbientLight(0x404060);
        scene.add(ambientLight);

        // Main directional light (sun)
        const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.2);
        sunLight.position.set(5, 15, 10);
        sunLight.castShadow = true;
        sunLight.receiveShadow = true;
        sunLight.shadow.mapSize.width = 1024;
        sunLight.shadow.mapSize.height = 1024;
        const d = 20;
        sunLight.shadow.camera.left = -d;
        sunLight.shadow.camera.right = d;
        sunLight.shadow.camera.top = d;
        sunLight.shadow.camera.bottom = -d;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 30;
        scene.add(sunLight);

        // Fill light from opposite side
        const fillLight = new THREE.DirectionalLight(0xcce0ff, 0.5);
        fillLight.position.set(-5, 5, -5);
        scene.add(fillLight);

        // Slight backlight
        const backLight = new THREE.DirectionalLight(0xffeedd, 0.3);
        backLight.position.set(-2, 3, -10);
        scene.add(backLight);

        // --- Create the mountain terrain (displaced plane) ---
        // Geometry with enough segments for detail
        const width = 24;
        const depth = 24;
        const segments = 64; // 64x64 grid gives smooth hills
        const geometry = new THREE.PlaneGeometry(width, depth, segments, segments);
        geometry.rotateX(-Math.PI / 2); // Lay flat (Y up)

        // Access position attribute
        const positionAttribute = geometry.attributes.position;
        const vertex = new THREE.Vector3();

        // Define mountain shape function: central peak with roughness
        for (let i = 0; i < positionAttribute.count; i++) {
            vertex.x = positionAttribute.getX(i);
            vertex.z = positionAttribute.getY(i); // Because we rotated, original Y is now Z? Wait careful:
            // After rotateX(-PI/2), the original Y (0) becomes -Z? Let's reason:
            // Original PlaneGeometry has vertices (x, y, z) with y=0, z = depth coordinate.
            // After rotation around X by -90 degrees, the original Y (0) goes to -Z, and original Z goes to Y.
            // But simpler: we want to use the flat coordinates in the plane's local space.
            // We'll just work in the rotated space: local X and Z are the horizontal axes, Y is up.
            // After rotation, the positions are such that:
            // - x remains x
            // - y is now -original_z (but original_z ranged from -depth/2 to depth/2)
            // - z is now original_y (which was 0)
            // So to get the horizontal coordinates, we need (x, -y) ? This is messy.
            // Better: don't rotate the geometry; instead modify vertices in place and then rotate.
            // Let's do simpler: create geometry without pre-rotation, modify heights in Y direction, then rotate.
            // I'll recreate geometry without rotation, modify Y, then rotate the whole mesh.
        }

        // Simpler: Re-do from scratch without pre-rotate, we'll rotate the mesh after modification.
        // Let's clear and create new geometry correctly.
        
        // I'll start over for clarity inside this block, but since we're in a script, I'll redefine.
        // Remove the previous geometry and start fresh.
        
        // -- Fresh start for terrain --
        const terrainGeo = new THREE.PlaneGeometry(22, 22, 70, 70);
        const posAttr = terrainGeo.attributes.position;
        const center = new THREE.Vector2(0, 0);
        
        // Height function: central peak with some noise and a secondary peak
        for (let i = 0; i < posAttr.count; i++) {
            const x = posAttr.getX(i);
            const z = posAttr.getY(i); // PlaneGeometry has y=0, and z is in Y attribute? Actually PlaneGeometry has (x, y, 0) with y being the other dimension. Let's check: standard PlaneGeometry gives vertices (x, y, 0) where x in [-w/2, w/2], y in [-h/2, h/2]. So to get 2D coordinates, we use x and y.
            // We'll treat x and y (which is actually the second coordinate) as the ground plane. Then we set the real Z as height? But we want Y up. So we need to map: (x, y) -> height in Y, and set Z = original y? No, better: we'll construct a custom geometry where we set (x, height, z) directly.
            // This is getting too twisted. I'll instead create a grid manually via BufferGeometry to have full control.
            // But for simplicity and clarity, let's use a ConeGeometry for the mountain and add trees around? That might not look like a natural mountain.
            // I'll stick to the manual grid approach to ensure correct axis orientation.
        }

        // Let's build a custom grid geometry from scratch to avoid confusion.
        const gridSize = 43;
        const spacing = 0.4;
        const w = (gridSize - 1) * spacing;
        const h = (gridSize - 1) * spacing;
        const vertices = [];
        const normals = [];
        const indices = [];
        const heightCoef = 10;

        // Generate vertices
        for (let i = 0; i < gridSize; i++) {
            const x = (i - (gridSize-1)/2) * spacing;
            for (let j = 0; j < gridSize; j++) {
                const z = (j - (gridSize-1)/2) * spacing;
                // Calculate distance from center
                const dist = Math.sqrt(x*x + z*z);
                // Base mountain shape: exponential peak with some sine-wave rocks
                let y = heightCoef * Math.exp(-dist * dist / 20); // main peak
                // Add some ruggedness / smaller hills
                y += 0.4 * Math.sin(x * 1.5) * Math.cos(z * 1.3);
                y += 0.3 * Math.sin(x * 3.0) * 0.5;
                // Flatten near edges slightly
                if (dist > 8) y *= Math.max(0, 1 - (dist-8)/6);
                // Ensure minimum near zero
                y = Math.max(0, y);
                
                vertices.push(x, y, z);
                
                // Placeholder normals (will recompute later)
                normals.push(0, 1, 0);
            }
        }

        // Generate indices for two triangles per grid cell
        for (let i = 0; i < gridSize - 1; i++) {
            for (let j = 0; j < gridSize - 1; j++) {
                const a = i * gridSize + j;
                const b = i * gridSize + j + 1;
                const c = (i + 1) * gridSize + j;
                const d = (i + 1) * gridSize + j + 1;

                // Two triangles: a-b-c and b-d-c
                indices.push(a, b, c);
                indices.push(b, d, c);
            }
        }

        const mountainGeo = new THREE.BufferGeometry();
        mountainGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        mountainGeo.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
        mountainGeo.setIndex(indices);
        
        // Compute normals for proper lighting
        mountainGeo.computeVertexNormals();

        // Material with a natural rock/grass color, and a bit of variation based on height would be nice,
        // but we'll keep it simple with a phong material and a single color.
        const mountainMat = new THREE.MeshPhongMaterial({
            color: 0x888c8d,
            emissive: 0x000000,
            shininess: 10,
            flatShading: false,
            side: THREE.DoubleSide // to see underside if camera goes low, but not necessary
        });

        const mountain = new THREE.Mesh(mountainGeo, mountainMat);
        mountain.castShadow = true;
        mountain.receiveShadow = true;
        mountain.position.y = 0;
        scene.add(mountain);

        // Add a subtle base plane to catch shadows and extend the ground
        const groundPlaneGeo = new THREE.CylinderGeometry(12, 12, 0.5, 60);
        const groundPlaneMat = new THREE.MeshPhongMaterial({ color: 0x5d7a5c, side: THREE.DoubleSide });
        const groundPlane = new THREE.Mesh(groundPlaneGeo, groundPlaneMat);
        // groundPlane.rotation.x = -Math.PI / 2;
        groundPlane.position.y = 0.5;
        groundPlane.receiveShadow = true;
        scene.add(groundPlane);

        // --- Helper function to create a simple tree ---
        function createTree(posX, posY, posZ, scale = 1) {
            const group = new THREE.Group();
            
            // Trunk (brown cylinder)
            const trunkGeo = new THREE.CylinderGeometry(0.25 * scale, 0.35 * scale, 1.2 * scale, 6);
            const trunkMat = new THREE.MeshPhongMaterial({ color: 0x8b5a2b });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 0.6 * scale; // half height
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            group.add(trunk);

            // Foliage (green cones) - multiple layers for fuller look
            const foliageMat = new THREE.MeshPhongMaterial({ color: 0x2e7d32 });
            
            // Bottom foliage
            const foliage1 = new THREE.ConeGeometry(0.7 * scale, 0.9 * scale, 8);
            const mesh1 = new THREE.Mesh(foliage1, foliageMat);
            mesh1.position.y = 1.2 * scale + 0.45 * scale;
            mesh1.castShadow = true;
            mesh1.receiveShadow = true;
            group.add(mesh1);
            
            // Top foliage
            const foliage2 = new THREE.ConeGeometry(0.5 * scale, 0.8 * scale, 6);
            const mesh2 = new THREE.Mesh(foliage2, foliageMat);
            mesh2.position.y = 1.9 * scale + 0.4 * scale;
            mesh2.castShadow = true;
            mesh2.receiveShadow = true;
            group.add(mesh2);

            group.position.set(posX, posY, posZ);
            return group;
        }

        // --- Scatter trees on the mountain ---
        // We need to sample the height at random (x, z) using the same formula used for vertices
        // to place trees on the surface.
        function getHeightAt(x, z) {
            const dist = Math.sqrt(x*x + z*z);
            let y = heightCoef * Math.exp(-dist * dist / 20);
            y += 0.4 * Math.sin(x * 1.5) * Math.cos(z * 1.3);
            y += 0.3 * Math.sin(x * 3.0) * 0.5;
            if (dist > 8) y *= Math.max(0, 1 - (dist-8)/6);
            return Math.max(0.1, y);
        }

        const treeCount = 120;
        for (let i = 0; i < treeCount; i++) {
            // Random position within the mountain radius
            const angle = Math.random() * Math.PI * 2;
            const radius = 3 + Math.random() * 6; // between 3 and 9
            const x = Math.cos(angle) * radius * (0.8 + 0.4 * Math.random());
            const z = Math.sin(angle) * radius * (0.8 + 0.4 * Math.random());
            
            const groundY = getHeightAt(x, z);
            
            // Avoid placing trees in very low areas or too high on peak
            if (groundY < 0.4 || groundY > 3.2) continue;
            
            // Random scale for variety
            const scale = Math.random() * 0.4;
            
            const tree = createTree(x, groundY, z, scale);
            
            // Slight random rotation around Y
            tree.rotation.y = Math.random() * Math.PI * 2;
            
            scene.add(tree);
        }

        // Add a few trees on the lowerÂ§ñÂõ¥
        for (let i = 0; i < 30; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 9 + Math.random() * 4;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const groundY = getHeightAt(x, z);
            if (groundY < 0.3) continue;
            const tree = createTree(x, groundY, z, 0.5 + Math.random()*0.5);
            tree.rotation.y = Math.random() * Math.PI * 2;
            scene.add(tree);
        }

        // --- Add some rocks / small boulders for detail (optional) ---
        const rockMat = new THREE.MeshPhongMaterial({ color: 0x888c8d, emissive: 0x111111 });
        for (let i = 0; i < 40; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 2 + Math.random() * 8;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const y = getHeightAt(x, z);
            if (y < 0.5 || y > 2.8) continue;
            
            const rockGeo = new THREE.DodecahedronGeometry(0.2 + Math.random()*0.3);
            const rock = new THREE.Mesh(rockGeo, rockMat);
            rock.position.set(x, y, z);
            rock.castShadow = true;
            rock.receiveShadow = true;
            rock.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            scene.add(rock);
        }

        // --- Add a small snow cap on the peak (just for visual interest) ---
        // const snowGeo = new THREE.SphereGeometry(0.9, 10, 10);
        // const snowMat = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x335566 });
        // const snowCap = new THREE.Mesh(snowGeo, snowMat);
        // snowCap.position.set(0, 9.2, 0);
        // snowCap.castShadow = true;
        // snowCap.receiveShadow = true;
        // scene.add(snowCap);

        // --- A few floating particles to suggest mist or birds (optional) ---
        const mistParticles = new THREE.BufferGeometry();
        const mistCount = 50;
        const mistPositions = new Float32Array(mistCount * 3);
        for (let i = 0; i < mistCount; i++) {
            mistPositions[i*3] = (Math.random() - 0.5) * 30;
            mistPositions[i*3+1] = 2 + Math.random() * 6;
            mistPositions[i*3+2] = (Math.random() - 0.5) * 30;
        }
        mistParticles.setAttribute('position', new THREE.BufferAttribute(mistPositions, 3));
        const mistMat = new THREE.PointsMaterial({ color: 0xddeeff, transparent: true, opacity: 0.15, size: 0.5 });
        const mist = new THREE.Points(mistParticles, mistMat);
        scene.add(mist);

        // --- Simple stars / sky enhancement? Not needed with fog.

        // Find points where the mountain surface intersects with the plane y=5
        const contourPoints = findContourPoints(5, 40);
        
        // Create contour lines using the new function
        createContourLines(contourPoints, scene);

        // --- Animation loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            controls.update(); // for damping
            
            renderer.render(scene, camera);
        }
        
        animate();

        // --- Handle window resize ---
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>